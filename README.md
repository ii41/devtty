# `/dev/tty`：终端竟可只是终端
```
$ cat > a.c && gcc a.c
#include <stdio.h>
int main() { fputs("hello world\n", stdout); return 0; }
$ ./a.out
hello world
$ ./a.out > a.txt
$ cat a.txt
hello world
```

刚刚接触C语言和命令行的时候，我们的课件上多少都会有跟上面这几行命令类似的内容，告诉你什么是标准输出，什么是重定向。

课件会告诉你：`a.out`把一串字符送向自己的标准输出。如果标准输出被重定向至文件的话，这段文字就会成为这个文件的内容。

而如果没有重定向，这串字符会被“打印出来”。

“打印出来”。打印到哪？到“终端”（*terminal*）。

一般的课程和书籍对终端的讲述到此为止。对你和你的程序而言，终端就是输入输出，就是`stdin`、`stdout`、`stderr`。既不在这之上，也不在这之下。

那么`less`之类的程序如何控制终端翻页？`ls`之类如何给终端输出上色？库。`ncurses`之类的库。

这些库又是怎么做到这点的呢？魔法吧。

那么我们来找出魔法背后的科学原理吧！

如果终端和输入输出真的就是一回事，重定向这种会向终端施魔法的软件的标准输出会怎样呢？我们用`vim`试一试。

```
$ # 各位想必记得正常打开vim之后你按Ctrl-C它会嘲讽你。以这个方式打开的vim也是不吃Ctrl-C的。
$ # :q<Enter>还是有用的，但是为了安全，建议另开一个终端准备kill。
$ vim -uNONE > a.txt
Vim: Warning: Output is not to a terminal
```

`kill`掉`vim`之前，我们可以先`cat a.txt`一下。

咦，终端闪烁了一下，然后重置了？好像一瞬间看见了`vim`的初始界面？

跟据你的系统，你所见的现象会有所不同。但是你一定会发现，`cat`这个仅仅只会把文件内容输出给自己的标准输出的软件，一瞬间似乎也使用了`vim`操纵
终端的魔法。

也就是说，魔法是可以存储在文件里的。